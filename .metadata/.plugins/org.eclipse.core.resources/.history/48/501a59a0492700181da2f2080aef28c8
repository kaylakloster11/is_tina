/*
 * UARTproj.c
 *
 *  Created on: Mar 12, 2018
 *      Author: kaylak
 */

#include <stdint.h>
#include <stdbool.h>
#include "driverlib/interrupt.h"
#include "driverlib/rom.h"
#include "driverlib/rom_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "driverlib/gpio.h"
#include "UARTproj.h"
#include "FPS.h"

void UART_CONFIG(void){
    GPIO_PORTP_BASE
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA | SYSCTL_PERIPH_GPIOP);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0 | SYSCTL_PERIPH_UART6);

    GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
    GPIOPinConfigure(GPIO_PA0_U0RX);
    GPIOPinConfigure(GPIO_PA1_U0TX);
    ROM_UARTConfigSetExpClk(UART0_BASE, ClockSRCFreq, 115200
                            (UART_CONFIG_WLEN_8 | UART_CONFIG_PAR_NONE | UART_CONFIG_STOP_ONE));

    GPIOPinTypeUART(GPIO_PORTP_BASE, GPIO_PIN_0 | GPIO_PIN_1);
    GPIOPinConfigure(GPIO_PP0_U6RX);
    GPIOPinConfigure(GPIO_PP1_U6TX);
    ROM_UARTConfigSetExpClk(UART6_BASE, ClockSRCFreq, 9600,
                            (UART_CONFIG_WLEN_8 | UART_CONFIG_PAR_NONE | UART_CONFIG_STOP_ONE));

    ROM_IntEnable(INT_UART0 | INT_UART6);
    ROM_UARTIntEnable(UART0_BASE, UART_INT_RX);
}

void MENU_DISPLAY(void){
    UART_send_A0("MENU Options:", 13);
    UART_send_byteA0(0x0A);
    UART_send_A0("1.Check Print", 13);
    UART_send_byteA0(0x0A);
    UART_send_A0("2.Enroll Print", 14);
    UART_send_byteA0(0x0A);
    UART_send_A0("3.Delete Print", 14);
    UART_send_byteA0(0x0A);
    UART_send_A0("4.Delete ALL", 12);
}


void UART_send_byteA0(const uint8_t * data){
     while(UARTBusy(UART0_BASE)); //May have to change to using the TXIFG flag
         UARTCharPut(UART0_BASE, data);
  }

  void UART_send_A0(const uint8_t * data, uint32_t length){
      int i = 0;
      for(i=0 ; i<length ; i++){
          UART_send_byteA2(data[i]);
      }
  }

  void UART_send_byteA6(const uint8_t * data){
       while(UARTBusy(UART6_BASE)); //May have to change to using the TXIFG flag
           UARTCharPut(UART6_BASE, data);
    }

    void UART_send_A6(const uint8_t * data, uint32_t length){
        int i = 0;
        for(i=0 ; i<length ; i++){
            UART_send_byteA2(data[i]);
        }
    }

  void UART6_IRQHandler(void){
      uint32_t IntStatus = ROM_UARTIntStatus(UART0_BASE, true);
      ROM_UARTIntClear(UART0_BASE, IntStatus);
         if (FP_state == FP_WAIT_RSP)
            {
                rsp_databuf[FPS_byte_count++] = UARTCharGetNonBlocking(UART0_BASE);
                if(FPS_byte_count == FP_RSP_PACKET_LENGTH)
                {
                    FP_state = FP_PROCESS_RSP;
                    UARTIntClear(UART6_BASE, UART_INT_RX);
                }
           }
         else if (FP_state == FP_WAIT_DATA)
             {
                 data_databuf[FPS_byte_count++] = UARTCharGetNonBlocking(UART0_BASE);
                 if(FPS_byte_count == FP_DATA_PACKET_LENGTH )
                     {
                         FP_state = FP_PROCESS_RSP;
                         UARTIntClear(UART6_BASE, UART_INT_RX);
                     }
             }
     }

  void UART0_IRQHandler(void){
      uint32_t IntStatus = ROM_UARTIntStatus(UART0_BASE, true);
      ROM_UARTIntClear(UART0_BASE, IntStatus);
      BaseType_t xHigherPriorityTaskWoken = pdFALSE;
      uint8_t input = UARTCharGetNonBlocking(UART0_BASE);
      switch(input){
      case '1':
          xEventGroupSetBitsFRomISR(xUserInEvent, FP_CHECKID_TASK_BIT, &xHigherPriorityTaskWoken);
          portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
          break;
      case '2':
               xEventGroupSetBitsFRomISR(xUserInEvent, FP_ENROLL_TASK_BIT, &xHigherPriorityTaskWoken);
               portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
               break;
      case '3':
               xEventGroupSetBitsFRomISR(xUserInEvent, FP_DELETEID_TASK_BIT, &xHigherPriorityTaskWoken);
               portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
               break;
      case '4':
               xEventGroupSetBitsFRomISR(xUserInEvent, FP_DELETEALL_TASK_BIT, &xHigherPriorityTaskWoken);
               portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
               break;
      }
  }



